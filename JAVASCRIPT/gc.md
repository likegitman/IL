# GC
흔히 gc라고 명칭하는 것은 상황에 따라 2개로 나뉜다.  
`Garbage Collection`, `Garbage Collecter`  
먼저 첫 번째 가비지 컬렉션이란 메모리를 식별하고 해제하는 매커니즘을 의미하고  
두 번째 가비지 컬렉터는 메모리 관리를 수행하는 알고리즘 또는 프로그램을 말한다.  
두 가지 용어는 비슷해 헷갈릴 수 있어 상황에 따라 잘 사용해야 한다.

#### ex)
> 가비지 컬렉터는 더 이상 사용되지 않는 객체를 식별하고 제거한다.`  
> 가비지 컬렉션은 자동으로 수행된다.

이 IL에 작성할 내용은 가비지 컬렉션에 가깝다. (참고!)

## GC란?
js는 메모리를 자동으로 관리해준다.  
GC는 메모리 관리 기법 중에 하나이다.  
js에서는 변수, 객체 등 개발자가 만든 모든 것은 자동으로 메모리가 할당된다.  
이렇게 동적으로 할당했던 메모리들 중에 사용되지 않는 메모리를 해제하지 않으면  
쓸데없는 공간을 차지하게 되기 때문에 메모리를 해제 해주는 과정이 필요하다.  

이때 과정을 가비지 컬렉션이라하며 이 과정을 수행하는 것은 가비지 컬렉터라고 부른다.  
요약하자면 동적으로 할당됐던 메모리들의 누수를 막고 효율적으로 관리하기 위해 사용되는 메모리 관리 방법이다.  
js는 개발자가 모르게 내부적으로 사용되지 않는 메모리들을 자동으로 해제해준다.

**어떻게 사용되지 않는 것을 판별하고 해제해주는걸까?**

## 도달 가능성
js의 가비지 컬렉션은 도달 가능성이라는 기준을 갖고 사용되는 값인지 아닌 값인지를 판단한다.  
여기서 도달 가능성이 있는 값이란 말그대로 어떤 방식으로든 접근이 가능한 값을 의미한다.  
당연히 도달 가능성이 있는 값은 GC가 메모리를 해제하고 삭제하지 않는다.

### 도달 가능성 X
```js
let obj = { name: 'woonrin' };
```
위 코드의 obj 객체는 `{ name: 'woonrin' }`이라는 객체를 참조하는 화살표가 만들어진다.  
이 화살표가 있는 한 위 객체는 도달 가능성이 있는 값이다.

하지만 obj의 값을 다른 값으로 재할당 한다면 위 객체를 가리키던 화살표가 사라지게 될 것이다.  
```
let obj = { name: 'woonrin' };

obj = null;
```
이렇게 되면 어떻게될까?  
js의 가비지 컬렉터는 더 이상 위 객체가 사용되지 않는 값 즉, **도달 가능성이 없는 값**으로 인식하고  
`{ name: 'woonrin' }` 데이터를 삭제하고 메모레에서도 삭제해준다. 자동으로.

다음과 같은 과정이 일어난 것이다.
```
// 메모리 생성
1. { name: 'woonrin' } 객체가 메모리에 생성 되고 obj는 이 객체를 참조한다.
// obj = null
2. obj는 참조하는 값이 없어지고 { name: 'woonrin' } 객체를 참조하는 건 아무것도 없다.
// GC 식별
3. js의 GC는 { name: 'woonrin' }이 도달 가능성이 없다고 판단하고 가비지(쓰레기)로 인식한다.
// 메모리 해제
4. 가비지로 인식 된 객체의 데이터를 삭제하고 메모리를 해제한다.
// 메모리 정리
5. 메모리는 해제 된 것이지. 삭제 된 것이 아니다. 즉, 다시 사용가능한 상태가 되어 재사용 할 수 있다.
```

### 도달 가능성 O
```js
let obj = { name: 'woonrin' };
let obj2 = obj;

obj = null;
```
위 코드에서도 { name: 'woonrin' }가 가비지로 취급될까?  
obj2는 obj가 참조하는 객체를 같이 참조 중이기에 obj가 다른 값으로 덮어 씌워져도 객체에 접근할 수 있다.  
이렇게 되면 { name: 'woonrin' } 객체는 도달 가능성이 있는 값이기에 가비지 컬렉터는 메모리를 해제하지 않는다.  

간단하다!

## Mark-and-Sweep
현대 js 엔진의 GC는 Mark-and-sweep이라는 알고리즘을 이용한다.  
간단하게 정리해보면 아래와 같은 알고리즘이다.  
```
1. root 정보를 수집하고 이를 mark한다.
2. 이 root가 참조하고 있는 객체들을 방문하고 방문한 객체들은 mark한다.
3. 여기서 그치지 않고 mark가 된 객체들이 참조하는 다른 객체들도 찾아가 mark한다.
4. 마지막으로 mark 되지 않은 객체는 메모리에서 해제한다.
```
tree를 탐색하는 것과 같다.  
한 번 mark한 객체는 기억하고 있기 때문에 같은 객체를 다시 방문하는 과정은 생기지 않는 효율적인 방법이다.  
위에서 말하는 root란 전역 변수라고 생각하면 된다. 가장 먼저 접근가능 한 값.

js는 내부적으로 지금까지 설명한 과정을 거쳐 개발자가 모르게 메모리를 효율적으로 관리한다.  
하지만 그럼에도 개발자는 메모리 누수가 나지 않도록 관리해야 한다.

## 메모리 누수 가능성이 있는 경우
### 전역 변수
전역 변수는 알다시피 어디에 있든 접근이 가능하다.  
그래서 전역 변수를 null로 할당해도 GC가 사용되는 값인지 아닌지를 판단하기 어렵다.

#### 해결 방법
이를 해결하는 방법으로는 전역 스코프에 변수 선언을 최대한 줄이고  
함수 스코프로 선언하면 GC가 판단하기 수월해진다.

### 이벤트 리스너
```js
const button = document.getElementById('button');
button.addEventLitsner('click', () => console.log('클릭!'));
```
js에서 자주 사용하는 것 중 하나 `addEventLitsner`  
위 메서드는 event를 등록만하고 해제하지 않는다.

#### 해결
`addEventLitsner`는 button을 참조하여 가비지 대상이 되지 않는다.  
그래서 event를 해제하고 싶다면 `removeEventLitsner` 메서드를 사용하면 간단하게 해결할 수 있다.
```js
const button = document.getElementById('button');
button.addEventLitsner('click', () => console.log('클릭!'));
button.removeEventLitsner('click', () => console.log('클릭!'));
```

### setTimeout, setInterval
스케쥴링 함수는 일부러 해제하지 않으면 `addEventLitsner`와 같이 자동으로 해제되지 않는다.  

#### 해결
스케쥴링을 담은 별도의 변수를 생성한 후 각각 맞는 정리 함수에 넣어 메모리 누수를 막을 수 있다.  
보편적으로 timerId, intervalId라고 짓는다.
```js
// setTimeout
const timerId = setTimeout(() => {
  console.log('timeout!');
}, 2000);

clearTimeout(timerId);

// setInterval
const invervalId = setInterval(() => {
  console.log('interval!');
}, 2000);

clearInterval(intervalId);
```
