# V8
Google이 개발한 오픈소스이며 c++로 만든 javascript엔진이다. 

## 사용이유
컴퓨터는 0과 1밖에 이해하지 못하는 저수준이다. 하지만 js같은 고수준 언어의 파일을 이해하고 명령을 실행할 수 있다. 

이처럼 컴퓨터가 사람이 작성한 js파일을 읽을 수 있는 이유는 바로 javascript엔진이 있기 때문이다. v8은 웹 브라우저 내부에서 

js 수행 속도의 개선을 목표로 처음 고안되었다. js엔진이 V8만 있는게 아니기때문에 그 이전에 사용되던 js 엔진들이 존재한다. 

하지만 다른 js 엔진은 웹 특성상 유저와 상호작용을 위해 즉시성이 있는 인터프리터 방식을 사용하는데 인터프리터는

코드가 많아질수록 속도가 느려진다는 단점이있다. 이 점을 보완한 js엔진이 V8인데 인터프리터 대신에

JIT(Just In Time) 컴파일러를 구현해 코드 실행 시 js 코드를 머신 코드로 컴파일한다. 머신 코드란 컴퓨터가

직접 실행할 수 있는 이진 코드를 의미한다. 여기서 js 코드를 머신 코드로 컴파일하는 이유는 컴퓨터 안에는

마이크로프로세서라는 것이 있는데 CPU의 핵심 기능을 통합한 집적 회로이다. 개발자가 어떤 코드를 짜서 컴퓨터에게

일을 시키려면 결국 마이크로프로세서가 해석할 수 있는 언어로 전달해야한다. 해석할 수 있는 언어들은 하드웨어와

직접 소통할 수 있는 코드들이다. 따라서 흔히 부르는 기계어, 머신 코드라고 불린다. 따라서 개발자는 고수준 언어를

작성하지만 결국 머신 코드로 컴파일 되어야 CPU가 이해하고 처리할 수 있게된다.

### JIT 컴파일러
프로그램을 실행하는 런타임 시점에 기계어로 변환한다. JIT 컴파일링을 통해 최적화 할 코드를 선별한 후에 해당 코드들만

컴파일한다. 이런 기법은 프로그램의 실행속도를 빠르게 하기 위해 사용된다.

![image](https://github.com/likegitman/TIL/assets/105215297/0a26dd97-fd92-46f1-aeab-9a5a830d7c95)

### Parser
V8은 js 소스코드를 가져와서 Parser에게 전달한다. 이때 Parser는 Lexical Analysis라는 과정을 통해 코드를

**토큰**으로 분해한다. Lexical Analysis는 어휘 분석이라 불리는데 컴파일러나 인터프리터에 프로그램의 소스코드를

입력받아 토큰이라 불리는 최소 의미 단위로 분해하는 과정을 말한다. `ex) let num = 10; -> ['let', 'num', '=', '10', ';']`

공백은 의미 없는 부분으로 간주되어 무시될 수 있다.

### Abstract Syntax Tree
Parser에서 분해된 토큰을 바탕으로 AST tree를 생성한다. AST tree는 추상 구문 트리로 소스 코드를 계층적이고

구조화된 트리 형태로 나타낸 데이터 구조이다. 컴파일러, 인터프리터에서 중요한 역할을 한다. AST는 언어의 문법 규칙을

기반으로 만들어진다. 각 노드는 프로그램의 구문 구조를 나타낸다. `let num = 10;`을 나타내면

```
Program
  └── VariableDeclaration (let)
      ├── Identifier (num)
      └── Literal (10)
```
위와 같이 트리가 구성될 것이다. Program은 루트 노드, VariableDeclaration은 변수를 선언하는 구문을 나타내는 노드이며

Identifier는 변수의 이름을 나타내는 노드이다. Literal은 변수의 값을 나타내는 노드이다.

### Interpreter Ignition
AST에서 나온 코드가 인터프리터에게 전달된다. 여기서 인터프리터는 Ignition을 나타낸다. Ignition에서는

AST를 Bytecode로 중간 번역하고 코드를 빠르게 실행시킨다. Bytecode란 고수준 언어로 작성된 소스코드를 가상머신이

편하게 이해할 수 있도록 중간 코드로 한 번 컴파일 한 것을 의미한다. CPU가 아닌 가상 머신에서 이해할 수 있는

코드를 위한 이진 표현법이다. 0과 1로 구성돼있다. Ignition을 개발할 때는 모든 소스를 한 번에 해석하는 컴파일 방식이

아니라 한 줄씩 실행할 때마다 해석하는 인터프리터 방식을 채택해 3가지 장점들을 얻고자했다.

#### 1. 메모리 사용량 감소
js 코드에서 기계어로 컴파일 하는 것보다 바이트 코드로 컴파일하는게 더 편하다.
#### 2. parsing 시에 오버헤드 감소
바이트 코드가 간결하기에 다시 parsing하기 편하다.
#### 3. 컴파일 파이프라인의 복잡성 감소
Optimizing이든 Deoptimizing이든 바이트 코드 하나만 생각하면 되기에 편해진다.

### Bytecode 실행 -> TurboFan -> Optimized
Bytecode를 생성 및 실행한다. V8 엔진은 런타입 과정 중 프로파일러에게 지속적인 프로파일링을 통해 

Hot spot(반복되어 사용하는 코드) 등의 과열지점을 찾는다. Bytecode가 실행될 때 프로파일러는 프로파일링 데이터를

수집해 최적화 할 수 있는 부분을 기록한다.

### 컴파일러는 프로파일러에게 전달받은 내용을 바탕으로 기계어로 변환하여 최적화를 진행한다.
최적화 가능한 부분을 찾으며 프로파일러는 이를 컴파일러에게 전달하고 컴파일러는 인터프리터에 의하여 실시간으로

웹사이트가 구동되는 동안 필요한 부분을 기계어로 변환하여 최적화를 진행한다. 이때 과열코드를 TurboFan(최적화 컴파일러)로

전달해 최적화 컴파일을 진행한다. 최적화된 코드가 예상치 못한 상황이나 조건 변경 등이 일어날 때 Deoptimizing(비최적화)가

발생할 수 있다. 하지만 Deoptimizing된 코드도 상황에 따라서 얼마든지 다시 최적화 컴파일링 되기도한다.

### 최적화 코드를 실행
최적화 코드를 수행할 때가 되면 Bytecode 대신에 컴파일러가 변환한 최적화된 코드가 그 자리를 대체하여 실행된다.

최적화 기법으로는 **Hidden Class**, **Inline Caching** 등의 여러가지 기법을 사용한다.

#### Hidden Class
V8은 객체에 새로운 프로퍼티를 추가할 때 hidden class를 생성하고 hidden class에 프로퍼티의 정적인 위치를

저장함으로써 실제 데이터가 저장되어 있는 위치에 대한 **pointer**를 제공한다. 이로 인해 런타임에 데이터 접근이

필요없어지고 고전적인 class 기반의 최적화를 할 수 있다. 이렇게하면 위치 정보를 해석할 필요가 없어져 더 빨라진다.

#### Inlining
호출 지점을 호출된 함수의 내용으로 바꾸는 과정이다. 만약 자주 사용되는 코드가 함수를 호출하는 코드라면 이것을

함수의 내용으로 바꿔버린다. `fn() -> function fn() { ... }`
