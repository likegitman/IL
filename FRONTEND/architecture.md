# Architecture
아키텍처의 해석은 저마다 다르지만 간단히 말하면 **좋은 구조**를 만드는 것이다. 이 좋은 구조를 만들기 위해서는

분류를 잘 해야 되는데 이 분류를 잘하기 위해 프론트엔드에서는 MVC 패턴을 많이 사용하고 유명한 패턴이다.

## MVC
### Model
멈춰있는 화면은 디자인과 다를게 없다. 그래서 화면 어딘가에서는 data가 반영 되어야한다.

Model이란 이러한 **data**를 주관하는 영역을 Model이라고 부른다. Model의 범위는 아키텍처마다 달라진다.

js의 Object일 수도 있고 서버 API로 받는 data, DB 일 수도 있다.

### View
UI에서 가장 중요한 것은 화면인데 View는 말 그대로 화면이다. 

프론트엔드에서 이 View란 HTML과 CSS로 만들어지는 결과물을 의미한다.

### Controller
UI 소프트웨어의 본질은 단순하다. 우선 데이터를 화면에 그립니다. 그리고 우리가 어떤 동작을 취하면 data가 바뀐다.

그리고 사용자가 어떤 동작을 취하면 data가 바뀐다. data가 바뀌면 다시 화면이 바뀐다. 이렇게 Modal의 data를 받아서

화면에 그리고 화면으로부터 사용자의 동작을 받아서 Model을 변경한다. 이러한 Model과 View 사이의 중간자 역할이 바로

Controller이다.

### 이유
Model, View, Controller로 나뉜 이유는
```
1. 화면을 다루는 문제와 데이터를 다루는 문제의 성격을 분리하고 싶었음
2. Model과 View간의 의존관계를 최소화 해서 화면의 수정이 데이터 수정에 영향을 미치지 않고
  데이터 수정이 화면의 수정에 영향을 미치지 않고자 함.
```

## MVVM
jQuery로 작업을 하다보니 상당히 불편한 점을 발견하게 되는데 데이터를 찾아서 데이터를 바꾸고 데이터를 수정하고

이벤트를 연결하고 이벤트를 수정하는 부분들에서 피곤한 반복적인 패턴이 나타나는 것을 발견했다.

서버에서는 개발할 때 HTML이 전체적으로 렌더링 돼서 `{{ }}, <?=, ?>, <%= %>` 같은 치환자를 통해 선언적으로

개발하는 반며에 jQuery는 전체 HTML을 갱신하면 문제가 생겨 수정해야 할 부분을 일일이 찾아 수정해야 됐다.

그래서 클라이언트도 서버처럼 선언형 프로그래밍을 할 수 있는 템플릿, 바인딩이라는 중요한 개념들이 

Angular에서 등장하게 되었고 이걸 계기로 웹 개발 방식이 완전히 바뀌게 된다. Model이 변하면 View를 수정하고,

View에서 이벤트를 받아 Model을 변경하는 Controller의 역할은 그대로 두고 이를 구현하는 방식이 jQuery, DOM 대신

템플릿, 바인딩을 통한 선언형 프로그래밍 방식으로 변하게 되었다. 이젠 DOM을 조작하는 코드가 사라지고 이 기능들은

프레임워크가 담당하게 된다. 그러면 이제 개발자는 화면에 그릴 data만 만들어서 프레임워크에 전달해주면 프레임워크가

알아서 그려준다. 이러면 개발자는 View와 Model만 다루게 된다. 이런 이유로 ViewModel이라 부르며 이 방식을

MVVM이라고 부른다. 3개의 대표적인 프론트엔드 프레임워크들도 방식이 다를 뿐 MVVM이라는 아키텍처는 그대로 유지한다.

### MVC와의 차이점
```
1. Controller의 반복적인 방식이 선언적인 방식으로 개선되었다.
2. Model과 View의 관점을 분리하려하지 않고 하나의 템플리승로 관리하려는 방식으로 발전했다.
(기존엔 class나 id 등으로 HTML에 간접적으로 접근하려 했지만 이젠 HTML에 직접 접근하는 방법)
```

### Container-Presenter 패턴
원래는 단위가 하나의 page 였지만 이젠 page안에 여러 모듈이 있고 modal 등의 여러 화면들이 하나의 화면에서

구성이 될 수 있도록 발전을 하게된다. 그래서 MVVM이 화면 단위가 아니라 좀 더 작은 단위로 만들어서 페이지를

만들 수 있도록 발전하게 된다. 이것이 현재 가장 익숙한 Component 패턴이다. Component는 재사용이 가능해야 한다는

원칙에 따라 가급적 비즈니스 로직을 포함시키지 않으려고 개발을 했다. 비즈니스 로직이란 특정 조직만의 독립적인

기능이기에 컴포넌트에 비즈니스 로직이 들어가게 되면 재사용성이 떨어지게 된다. 그래서 이걸 따로 분리할 수 있는데

비즈니스 로직을 가지고 있는 컴포넌트를 Container 컴포넌트, 아닌 컴포넌트는 Presenter 컴포넌트로 분리하는데

최상단, 1depth에 Container를 두고 비즈니스 로직을 관리한다. 이러한 것을 Container-Presenter 아키텍처이다.

이러한 패턴도 문제는 생긴다 바로 props가 끊도없이 하위 컴포넌트로 내려가는 props drilling 현상이 생길 수 있다.

이 문제를 해결하기 위해 새로운 아키텍처가 나타나는데 FLUX 패턴이다.

## FLUX 패턴
MVC의 개념에서 벗어나서 단방향 아키텍처를 만들자는 이야기가 나오게 되면서 단일 흐름의 FLUX 패턴이 발표된다.

![image](https://github.com/likegitman/TIL/assets/105215297/701947fd-caa0-4775-a99c-f2871e46742d)
기존의 컴포넌트 패턴을 지향하는 MVC가 아니라 View를 하나의 범주로 두고 View에서 Actino을 호출하면 Dispatcher를

통하여 Store라는 저장공간에 data가 보관이 되고 다시 View로 전달되는 흐름이다. 실제로 구현된 패턴은 아니었지만

이후 이런 FLUX 패턴을 구현한 전역 상태 관리 라이브러리인 Redux가 나오게된다. 기존의 props drilling 문제를 짚어주고

Store, Dispatch, Reducer 개념을 정확하게 정리하였다. FLUX 패턴은 View를 각각으로 보는 MVC와 달리 하나의 큰 개념으로

이해하고 View에서는 Dispatch를 통해 Action을 전달하면 Action은 Reducer를 통해 Store에 data가 저장된다.

이 data를 다시 View로 연결 되는 방식을 지향한다.

## 
