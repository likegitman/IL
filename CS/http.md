# HTTP
> `client`와 `server` 간에 통신을 하기 위한 `protocol`이다. 이 `protocol`은 수신자(브라우저) 측에 의해 요청이
> 초기화되는 `protocol`을 의미한다. 웹에서 이루어지는 모든 데이터 교환의 기초이며 하나의 완전한 문서는 텍스트,
> 레이아웃 설명, 이미지, 비디오, 스크립트 등의 불러온 하위 문서들로 재구성된다.

## Connectionless(비연결성)
> `HTTP`는 리소스 때문에 `client`와 `server`가 연결되어 있지 않다는 것이다. 만약 계속 연결되어 있다면 리소스가
> 계속해서 들어간다는 뜻이다. 하지만 연결을 해놓고 있지 않다면 **리소스**를 아끼기 때문에 더 많은 연결을 할 수 있다.
> 여기서 생기는 궁금증은 **연결되어 있지 않다면 통신을 어떻게 하는가?** 인데 `client`가 어떤 데이터를 요청하면
> `server` 응답을 하고 한번 맺었던 연결을 끊어버린다. 이렇게 통신을 하지만 `overhead`가 발생하는 단점도 있다.
> `overhead`란 어떠한 처리를 하기 위해 들어가는 간접적인 처리 시간과 메모리 등을 말한다.

## Stateless(무상태)
> 상태를 가지고 있지 않다는 뜻이다. `server`가 `client`의 상태를 가지고 있지 않는 이유 또한 **리소스**를
> 줄이기 위해서이다. 그렇다면 **무상태는 어떻게 리소스를 줄일까?** 가 궁금해진다. 먼저 `Stateless`방법이 아닌
> `Stateful`한 방법은 어떤 직원이 어떤 주문을 받았는지 모두 찾아다녀야 하고 당연히 리소스를 많이 소모하게 된다.
```
직원A: 마실 거 뭐 드시겠어요?
나: 콜라 주세요.

직원B: 뭐 필요한 거 있으세요?
나: 아까 시킨거 2잔 더 주세요.

직원C: 뭐 필요한 거 있으세요?
나: 아까 2잔 더 시켰는데 그냥 1잔만 주세요.
```
> `Stateful`한 방법은 요청할 때마다 저장을 하지 않고 모든 정보를 담아서 주문(요청)을 한다. 이러면 주문을 받은
> 직원을 일일이 찾을 필요가 없고 리소스를 많이 줄일 수 있다. 하지만 당연히 요청 때마다 모든 정보를 주기 때문에
> 이 정보를 각 서버에 전달해야 하기 때문에 요청이 복잡해진다는 단점도 있지만 많은 서버를 둬도 부담이 되지 않아
> 서
```
직원A: 마실 거 뭐 드시겠어요?
나: 콜라 주세요.

직원B: 뭐 필요한 거 있으세요?
나: 아까 A직원한테 콜라 시켰는데 거기에 콜라 2잔 더 주세요.

직원C: 뭐 필요한 거 있으세요?
나: 아까 A직원한테 콜라 시켰고, B직원한테 콜라 2잔 더 추가해달라 했는데, 추가해달라 한 콜라 1잔 취소해주세요.
```
